import re

import requests
import asyncio
from bs4 import BeautifulSoup
from telegram import Bot, Update, ReplyKeyboardMarkup
from telegram.ext import Application, MessageHandler, ContextTypes, CommandHandler, filters
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime, timedelta

BOT_TOKEN = '7044099465:AAEKAmQZ5B-JFNLZgA5Ze661m6_FzQCpa4Y'
USER_CHAT_IDS = ['457829882', '191742166']


bot = Bot(token=BOT_TOKEN)

CONDITIONS = {
    "—è—Å–Ω–æ": "–Ω—É, –≤—Å—ë —è—Å–Ω–æ ‚òÄÔ∏è",
    "–º–∞–ª–æ–æ–±–ª–∞—á–Ω–æ": "—á—É—á—É—Ç–∫–∞ –æ–±–ª–∞—á–Ω–æ üå§",
    "–æ–±–ª–∞—á–Ω–æ —Å –ø—Ä–æ—è—Å–Ω–µ–Ω–∏—è–º–∏": "—á—É—á—É—Ç–∫–∞ –æ–±–ª–∞—á–Ω–æ üå§",
    "–æ–±–ª–∞—á–Ω–æ": "—Ç–∞–∫ —Å–µ–±–µ, –æ–±–ª–∞—á–Ω–æ ‚òÅÔ∏è",
    "–ø–∞—Å–º—É—Ä–Ω–æ": "–Ω—É —Ç–∞–∫–æ–µ –ø–∞—Å–º—É—Ä–Ω–æ–µ üå•",
    "–Ω–µ–±–æ–ª—å—à–æ–π –¥–æ–∂–¥—å": "—á—É—Ç—å-—á—É—Ç—å –¥–æ–∂–¥—å üå¶",
    "–¥–æ–∂–¥—å": "–¥–æ—â—å üåß",
    "—Å–∏–ª—å–Ω—ã–π –¥–æ–∂–¥—å": "—Ç–æ–≥–æ –≤—Å—ë –∫–∞–∫–æ–π –¥–æ–∂–¥—å üåß",
    "—Å–Ω–µ–≥": "—Å–Ω–µ–≥ ‚ùÑÔ∏è",
    "–≥—Ä–æ–∑–∞": "–≥—Ä–æ–∑–∞ ‚ö°Ô∏è",
}

RU_PARTS = {
    'morning': '–£—Ç—Ä–æ–º',
    'day': '–î–Ω—ë–º',
    'evening': '–í–µ—á–µ—Ä–æ–º',
}

ICONS = {
    'morning': 'üåÖ',
    'day': 'üå§',
    'evening': 'üåá',
}


def fetch_forecast_from_html():
    url = "https://yandex.ru/pogoda/moscow/details"
    headers = {
        "User-Agent": "Mozilla/5.0",
        "Accept-Language": "ru-RU,ru;q=0.9"
    }

    response = requests.get(url, headers=headers, timeout=10)
    soup = BeautifulSoup(response.text, "html.parser")

    # –†—É—Å—Å–∫–∏–µ –º–µ—Å—è—Ü—ã
    months_ru = [
        '', '—è–Ω–≤–∞—Ä—è', '—Ñ–µ–≤—Ä–∞–ª—è', '–º–∞—Ä—Ç–∞', '–∞–ø—Ä–µ–ª—è', '–º–∞—è', '–∏—é–Ω—è',
        '–∏—é–ª—è', '–∞–≤–≥—É—Å—Ç–∞', '—Å–µ–Ω—Ç—è–±—Ä—è', '–æ–∫—Ç—è–±—Ä—è', '–Ω–æ—è–±—Ä—è', '–¥–µ–∫–∞–±—Ä—è'
    ]

    tomorrow = datetime.now() + timedelta(days=1)
    day = tomorrow.day
    month = months_ru[tomorrow.month]
    tomorrow_pattern = re.compile(rf'\b{day}\s+{month}\b', re.IGNORECASE)

    # –ò—â–µ–º article –ø–æ –∑–∞–≥–æ–ª–æ–≤–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â–µ–º—É –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ "4 –∏—é–ª—è"
    target_article = None
    for article in soup.select("article[data-day]"):
        heading = article.find("h3")
        if heading and tomorrow_pattern.search(heading.text):
            target_article = article
            break

    if not target_article:
        raise Exception(f"–ù–µ –Ω–∞–π–¥–µ–Ω –±–ª–æ–∫ <article> —Å –¥–∞—Ç–æ–π '{day} {month}'")

    date_str = f"{day} {month}".capitalize()
    mapping = {'m': 'morning', 'd': 'day', 'e': 'evening'}
    result = []

    for prefix, key in mapping.items():
        part = target_article.select_one(f'[style="grid-area:{prefix}-part"]')
        temp = target_article.select_one(f'[style="grid-area:{prefix}-temp"]')
        text = target_article.select_one(f'[style="grid-area:{prefix}-text"]')
        feels = target_article.select_one(f'[style="grid-area:{prefix}-feels"]')
        if not (part and temp and text and feels):
            continue

        emoji = ICONS.get(key, '‚ùì')
        cond = CONDITIONS.get(text.text.strip().lower(), text.text.strip().lower())
        result.append(
            f"{emoji} {RU_PARTS[key]}: {temp.text.strip()} (–ø–æ –æ—â—É—â–µ–Ω–∏—è–º {feels.text.strip()}), {cond}"
        )

    return f"üìÖ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ {date_str} üîÆ:\n\n" + "\n".join(result)



async def send_tomorrow_weather(bot_instance: Bot = None, chat_ids: list[str] = None):
    try:
        forecast = fetch_forecast_from_html()
        for chat_id in (chat_ids or USER_CHAT_IDS):
            await (bot_instance or bot).send_message(chat_id=chat_id, text=forecast)
    except Exception as e:
        for chat_id in (chat_ids or USER_CHAT_IDS):
            await (bot_instance or bot).send_message(chat_id=chat_id, text=f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–æ–≥–Ω–æ–∑–∞ –Ω–∞ –∑–∞–≤—Ç—Ä–∞: {e}")



async def send_today_weather():
    for chat_id in USER_CHAT_IDS:
        await bot.send_message(chat_id=chat_id, text="üå§ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")



async def handle_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.text == "üå§ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –∑–∞–≤—Ç—Ä–∞":
        await send_tomorrow_weather(chat_id=update.effective_chat.id)


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kb = [["üå§ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –∑–∞–≤—Ç—Ä–∞"]]
    markup = ReplyKeyboardMarkup(kb, resize_keyboard=True)
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–∫–∞–∂—É —Ç–µ–±–µ –ø—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –∑–∞–≤—Ç—Ä–∞.", reply_markup=markup)


async def start_bot():
    app = Application.builder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start_command))
    app.add_handler(MessageHandler(filters.TEXT, handle_button))

    loop = asyncio.get_running_loop()
    scheduler = AsyncIOScheduler()
    scheduler.add_job(send_today_weather, trigger='cron', hour=8, minute=45)
    scheduler.add_job(
        lambda: asyncio.run_coroutine_threadsafe(send_tomorrow_weather(app.bot), loop),
        trigger='cron',
        hour=19,
        minute=30
    )
    scheduler.start()

    print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω.")
    await app.run_polling()



if __name__ == "__main__":
    import nest_asyncio
    nest_asyncio.apply()

    loop = asyncio.get_event_loop()
    loop.create_task(start_bot())
    loop.run_forever()



